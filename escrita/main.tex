\documentclass[
12pt,        % tamanho da fonte
openright,   % capitulos comecam em paginas impares, insere paginas em branco se necessario
twoside,     % para impressao frente e verso, comente esta linha se for imprimir só frente.
a4paper,     % tamanho do papel
% -- opções da classe abntex2 -- retire o comentario para obter o comportamento
% chapter=TITLE,         % títulos de capítulos convertidos em letras maiúsculas
% section=TITLE,         % títulos de seções convertidos em letras maiúsculas
% subsection=TITLE,      % títulos de subseções convertidos em letras maiúsculas
% subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
% -- opções do pacote polyglossia --
% french,      % idioma adicional para hifenizacao
% spanish,     % idioma adicional para hifenizacao
brazil,       % idioma adicional para hifenizacao
english       % ultimo idioma eh o principal do documento
%
% ppgca.cls options
%
,englishwr      % For documents written in english, remove only the coment '%'
]{ppgca}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para que o primeiro parágrafo também seja 'indentado':
% troque \ifnum1=0 por \ifnum1=1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifnum1=0
\ifxetexorluatex
\PolyglossiaSetup{brazil}{indentfirst=true}
\PolyglossiaSetup{english}{indentfirst=true}
\else
\usepackage{indentfirst}
\fi
\fi

\graphicspath{ {./images/} }

%%%%%%%%%%%%%%%% VERSÃO DO DOCUMENTO: ORIGINAL OU CORRIGIDA
% Após as correções sugeridas pela banca serem efetuadas, retire os comentários
% da próxima linha.
%\versaodocumento{corrigida}

% Este arquivo foi baseado no modelo disponível em https://www.ctan.org/pkg/abntex2.

% Para gerar o indice, execute o comando makeindex:
% makeindex main

% O preambulo deve conter o tipo do trabalho, o objetivo,
% o nome da instituição e a área de concentração
\preambulo{Final Paper for the Bachelor in Computer Science program under Departamento de Computação e Matemática of the Universidade de São Paulo}

\usepackage{blindtext}

%---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\title{An IoT Smart Scale Proof of Concept for Smart Homes}
\author{Gabriel Carvalho Silva}
\local{Ribeirão Preto--SP}
\data{2025}
\orientador{Cléver Ricardo Guareis de Farias}
\coorientador{}
\tipotrabalho{Final Paper} % Dissertação ou Tese

% ---
% Espaçamentos entre linhas e parágrafos
% ---
% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

%#% you can change the language used (brazil) by set and uncomment the
%#% following command:
% \setdefaultlanguage{english}

% #% Options for the \setdefaultlanguage{} can be found at
% #% http://mirrors.ctan.org/macros/latex/contrib/polyglossia/polyglossia.pdf#page=5

% ---
% ---
% compila o indice
% ---
\makeindex
% ---
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para limpar o cabeçalho, troque \ifnum1=0 por \ifnum1=1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifnum1=0
\newcommand{\sectionbreak}{\clearpage
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}
\fi

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% ---
% Capa
% ---
\imprimircapa
% ---

% ---
% Folha de rosto
% (o * indica que haverá a ficha bibliográfica)
% ---
% \imprimirfolhaderosto
% ---

%---
% Imprime a folha de rosto em inglês (Opcional)
\coversheet{An IoT Smart Scale Proof of Concept for Smart Homes}
%---


% ---

% ---
% Inserir errata
% ---
% \begin{errata}
% Elemento opcional da NBR14724:2011. Exemplo:

% \vspace{\onelineskip}

% FERRIGNO, C. R. A. \textbf{Tratamento de neoplasias ósseas apendiculares com
% reimplantação de enxerto ósseo autólogo autoclavado associado ao plasma
% rico em plaquetas}: estudo crítico na cirurgia de preservação de membro em
% cães. 2011. 128 f. Tese (Livre-Docência) - Faculdade de Medicina Veterinária e
% Zootecnia, Universidade de São Paulo, São Paulo, 2011.

% \begin{table}[htb]
% \center
% \footnotesize
% \begin{tabular}{|p{1.4cm}|p{1cm}|p{3cm}|p{3cm}|}
%   \hline
%    \textbf{Folha} & \textbf{Linha}  & \textbf{Onde se lê}  & \textbf{Leia-se}  \\
%     \hline
%     1 & 10 & auto-conclavo & autoconclavo\\
%    \hline
% \end{tabular}
% \end{table}

% \end{errata}
% ---

% ---
% Inserir folha de aprovação
% ---

% Isto é um exemplo de Folha de aprovação, elemento obrigatório da NBR
% 14724/2011 (seção 4.2.1.3). Você pode utilizar este modelo até a aprovação
% do trabalho. Após isso, substitua todo o conteúdo deste arquivo por uma
% imagem da página assinada pela banca com o comando abaixo:
%
% \begin{folhadeaprovacao}
% \includepdf{folhadeaprovacao_final.pdf}
% \end{folhadeaprovacao}
%
% \begin{folhadeaprovacao}

%   \begin{center}
%     {\theauthor}

%     \vspace*{\fill}\vspace*{\fill}
%     \thetitle
%     \vspace*{\fill}

%     \hspace{.45\textwidth}
%     \begin{minipage}{.5\textwidth}
%         \imprimirpreambulo
%     \end{minipage}%
%     \vspace*{\fill}
%    \end{center}

%    Trabalho aprovado. \imprimirlocal, 21 de novembro de 2018:

%    \assinatura{\textbf{\thesupervisorlabel:} \\ Orientador}
%    \assinatura{\textbf{Professor} \\ Convidado 1}
%    \assinatura{\textbf{Professor} \\ Convidado 2}
%    \ifthenelse{\equal{\imprimirtipotrabalho}{Tese}}{
%      \assinatura{\textbf{Professor} \\ Convidado 3}
%      \assinatura{\textbf{Professor} \\ Convidado 4}
%    }{}

%    \begin{center}
%     \vspace*{0.5cm}
%     {\large\imprimirlocal}
%     \par
%     {\large\imprimirdata}
%     \vspace*{1cm}
%   \end{center}

% \end{folhadeaprovacao}
% ---

% ---
% Dedicatória
% ---
\begin{dedicatoria}
   \vspace*{\fill}
   \centering
   \noindent
   \textit{A minha avó, Maria Daria Rocha, e ao Gabriel de 10 anos que desenhava ideias e projetos em papel manteiga.} \vspace*{\fill}
\end{dedicatoria}
% ---

% ---
% Agradecimentos
% ---
\begin{agradecimentos}
Agradeço $\ldots$
\end{agradecimentos}
% ---

% ---
% Epígrafe
% ---
\begin{epigrafe}
    \vspace*{\fill}
        \begin{flushright}
                \textit{``E ao vencedor, as batatas `` \\
                          (Quincas Borba)}
        \end{flushright}
\end{epigrafe}
% ---

% ---
% RESUMOS
% ---

% resumo em português
% remover se o documento for em inglês
% \setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo
% \begin{resumo}
%   Este documento é um modelo \LaTeX para servir como base para edição
%   de uma dissertação a ser apresentada ao programa de pós-graduação em
%   Computação Aplicada do Departartamento de Computação e Matemática da
%   FFCLRP/USP.

% \noindent \textbf{Palavras-chave}: latex. abntex. editoração de texto.
% \end{resumo}

% resumo em inglês
\begin{resumo}[Abstract]
% \begin{otherlanguage*}{english}
This final paper develops of an Internet of Things (IoT) smart scale proof-of-concept (PoC) for smart home integration. The motivation for this work is to address key barriers to adoption in the field, specifically high costs, privacy concerns, and system scalability. This project aims to build a custom architectural solution to demonstrate a cost-conscious, privacy-by-design approach. The developed system consists of an embedded scale with facial recognition capabilities, a service layer for data management, and a client dashboard for data visualization and configuration. The design emphasizes an event-driven architecture using MQTT (Message Queuing Telemetry Transport) to ensure efficient and adaptive communication. Ultimately, this PoC will serve as a practical demonstration of best practices in the design of IoT systems and of the application of novel approaches in edge computing, offering valuable insight into interoperability and performance trade-offs for smart home health devices.

\vspace{\onelineskip}

\noindent \textbf{Keywords}: Internet of Things (IoT), Smart Homes, Embedded Systems, Facial Recognition, Adaptive Systems, Event-driven Architecture, MQTT, Proof-of-Concept
% \end{otherlanguage*}
\end{resumo}

% OBS: A numeração de páginas deve sempre começar em páginas ímpares,
% por isto o uso de \cleardoublepage.

% ---
% inserir lista de figuras
% ---
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\cleardoublepage
% ---

% ---
% inserir lista de quadros (opcional)
% ---
% \pdfbookmark[0]{\listofquadrosname}{loq}
% \listofquadros*
% \cleardoublepage
% ---

% ---
% inserir lista de tabelas
% ---
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\cleardoublepage
% ---

% ---
% inserir lista de abreviaturas e siglas
% ---
\begin{siglas}
  \item[TODO] TODO
\end{siglas}
% ---

% ---
% inserir lista de símbolos
% ---
\begin{simbolos}
  \item[$ \Gamma $] TODO
\end{simbolos}
% ---

% ---
% inserir o sumario
% ---
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---
% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual
\setcounter{page}{1}
\chapter{Introduction}
\section{Background}

The history of the Internet is a story of continuous expansion and integration. Starting in the late 1960s with ARPANET, a network for government and academic use, it was a tool for sharing information across an enclosed group of institutions and people. The adoption of the TCP/IP protocol in the early 1980s and the birth of the World Wide Web in the 1990s democratized this connectivity, paving the way to a modern digital world. Moreover, with the rise of affordable sensors, ubiquitous wireless technologies like Wi-Fi and 5G, and the vast processing power of cloud computing, the Internet's reach extended beyond traditional computers to encompass everyday objects. This transformation allowed devices to collect, share, and act on data autonomously, laying the groundwork for a ``network of things``, or Internet of Things (IoT).  

Internet-connected things include thermostats that can be controlled remotely from smartphones and smart body scales that allow one to graphically review the progress of diets using smartphones, for example. Moreover, smart scales detect gradual weight changes and, when integrated with smart home systems, create comprehensive health monitoring environments. This continuous data stream allows, for example, for healthcare agents to intervene earlier and more precisely, potentially reducing hospital admissions and healthcare costs \cite{panja2025medical}.

However, despite the increasing interest in IoT, the development of cost-effective IoT solutions currently face many different challenges. For instance, privacy features in many existing IoT development frameworks are relatively limited \cite{jin2020privacy}, which affects, for example, smart scale solutions reliability. Besides that, handling IoT sensor data, especially in terms of processing and integration with other data sources, has its own setbacks \cite{challenges2024nwamaka}. Likewise, there is no ground truth for project design and architecture, which raises the question of which service composition mechanism best fulfills the functional scalability requirements of IoT systems \cite{evaluation2020kung}. On top of that, buying a scale can be financially challenging, particularly for low-income individuals, and scales with advanced features cost significantly more than scales without these features \cite{affordability2021park}.

\section{Objective}

Within this context, this project aims to deliver a working prototype of a smart scale with face recognition capability. Therefore, it consists of an embedded system for weighing a subject and capturing their face image, a web service for managing weight records and performing face recognition, and a dashboard for measured data visualization. 

The development of the Proof-of-Concept (PoC) system takes into account cost and privacy concerns, as well as system scalability, considering different possible architecture styles \cite{dimartino2018iot}. It also explores and validates different aspects of such a system and their specific challenges following novel approaches from literature.

\section{Methodology}

This work followed the literature review to guide the understanding of current state of the art regarding IoT Systems, specially related to smart scales and privacy-aware scopes. Therefore, in order to follow up with the design and implementation of the system and subsequent evaluation of it, we opted for the ESP32 (the ESPCAM model specifically) as an accessible option for hardware solution and set a requirement for ESP32 compliant face embeddings extraction methods. Not only that, the architecture was defined by considering simplicity and extensibility capabilities besides functional requirements.

Several architectural styles were considered from current state of the art \cite{dimartino2018iot}, leading to the adoption of a reactive event-driven architecture. This decision is aligned with the nature of the expected functionality of a smart scale, in which retry policies were implemented for when face recognition failed, and in which system components can be decoupled for extensibility.

Therefore, the ESP32 was calibrated for weight measurement and implemented the face embedding extraction using pre-trained models, an event queue was used to bridge system components, a web service was developed to manage data acquisition and retrieval and a dashboard was also created to visualize weight measurements.

Finally, the usage of the system as a whole was put under daily tests leading to conclusions regarding the actual feasability of the solutions for the challenges concerning cost, privacy and performance.

\section{Structure of this paper}

The following chapters explore in more depth the various aspects of this project: Chapter 2 reviews literature and related work; Chapter 3 details the PoC development; and Chapter 4 brings to light the findings of this project.

\chapter{Theoretical Foundation}
\section{Internet of Things}

The Internet of Things (IoT) can be defined as an open and comprehensive network of intelligent objects that have the capacity to organize themselves, share information, react and act in situations faced and changes in the environment \cite{somayya2015smart}. IoT consists of an inter-network of physical devices like vehicles, buildings, and other items embedded with electronics, sensors, actuators, software, and network connectivity that allow these objects to collect and exchange data \cite{mehra2019home}. 

Naturally, communication is a key layer upon which any IoT solution is built and it involves a careful consideration of both the physical infrastructure and the logical architecture. At the physical layer, devices need to communicate wirelessly, and the choice of technology depends heavily on the specific application's requirements for bandwidth, range, and power consumption. For example, Wi-Fi is a common choice for many smart home devices due to its high bandwidth, which is essential for data-intensive tasks like streaming video from a security camera, and its widespread availability. However, Wi-Fi is also relatively power-intensive, which is a major drawback for battery-operated devices that need to run for months or years without a charge \cite{mocrii2018sys}.

In contrast, Bluetooth, and its more energy-efficient variant, Bluetooth Low Energy \cite{bluetooth}, is optimized for low-power, short-range communication, making it an ideal choice for wearable devices, fitness trackers, and other battery-powered sensors. Still, other emerging technologies such as LoRa \cite{lora}, which is specifically designed for long-range, low-power communication, are more suited for applications in smart cities or large-scale industrial IoT, as highlighted by Kane \textit{et al}. \cite{kane2022lora}. 

Beyond the physical layer, the logical architecture of communication is crucial to ensuring scalability, efficiency, and responsiveness in a heterogeneous IoT environment. The traditional request-response model, often implemented via HTTP/REST API calls, is a synchronous pattern in which a client sends a request to a server and waits for a response. This model is well-suited for many web applications but can be inefficient in an IoT context where devices may be intermittently connected and need to send data proactively rather than waiting for a request. 

A more robust and scalable solution for IoT is an event-driven architecture (EDA). In this paradigm, devices and services operate asynchronously, communicating through the publication and subscription of ``events.`` For example, when a user steps on the scale, the embedded system publishes a ``weight-measured`` event to a central message broker. Other services, such as a data processing worker or the face recognition service, that are interested in this event are automatically notified.

This publish-subscribe model, which is often facilitated by a lightweight messaging protocol such as Message Queuing Telemetry Transport (MQTT) \cite{mqtt}, is highly advantageous for IoT systems. MQTT is designed for resource-constrained devices and low-bandwidth, high-latency networks, making it an ideal fit for the project. An EDA allows for loose coupling between components, meaning a new device or service can be added to the system without requiring changes to existing components. This modularity is a key factor for scalability and adaptability. In addition, it enables adaptive, context-aware data acquisition strategies. 

In a system with low-frequency sensor data (weight) and high-latency operations (image processing for facial recognition), an event-driven model can optimize bandwidth and energy consumption. The system can be configured to only publish data when a significant change occurs (e.g., a weight measurement crosses a certain threshold) or when a specific condition is met, avoiding the need for continuous, wasteful polling. This adaptive approach is central to the proposed system's design, aiming to improve responsiveness and reduce resource consumption in a real-world smart home environment.

\section{IoT Sensors}

IoT devices are also called Smart Things, which can also be perceived as physical objects connected to the web with some sensing capabilities \cite{somayya2015smart}. Sensing is made possible by pairing embedded devices with sensors, actuators and other sorts of appendixes. Sensor are crucial for acquiring data and providing context for the interoperability of different IoT devices \cite{panja2025medical}. 

Sensors can be of many kinds and for many purposes. Temperature, umidity and proximity sensors are some examples of it. Weight sensors specifically are commonly a composiiton of load cells. The most widely used load cell is the strain gauge which is a thin foil resistor, the primary sensing element \cite{muller_load_2010}. Strain gauges measure variations in voltage once they are deformed, because the intensity of the electrical resistance variation in the strain gauges is proportional to the intensity of the applied force that deform them \cite{muller_load_2010}.

\section{IoT System Architectural Styles}

Figure \ref{fig:mocrii}\index{mocrii} shows a simplification of an IoT architecture focused on cloud solutions. The cloud computing approach offers high processing power and storage option, while edge computing is more limited when it comes to computing power. However, edge computing achieves privacy measures more easily than the cloud. Nevertheless, fog computing is another approach that takes processing power closer to embedded devices on the edge, while still keeping the cloud layer unware of sensitive information \cite{mocrii2018sys}. Therefore, depending on the goals for a project, the placement of system components and tasks should be placed accordingly to what every computing layer offers and limits.

\begin{figure}[ht]
  \caption{Cloud-based architecture of a smart home. (Screenshot from \cite[Fig.~1]{mocrii2018sys})}
  \centering
  \includegraphics[scale=0.3]{mocrii}
  \label{fig:mocrii}
\end{figure}

\section{Smart Homes}

A smart home system forms when interconnected devices, embedded with electronics, sensors, software, and network connectivity, work within a household. Mocrii \textit{et al}. \cite{mocrii2018sys}. define this system as having complementary user and system functions built upon a general IoT-based architecture. The devices themselves, often referred to as 'Smart Things,' possess embedded intelligence, identification, and automation capabilities designed to assist human life.

Seo \textit{et al}. \cite{seo_hepa_2015} proposed the Hexagonal Platform Architecture (HePA) as a reference architecture specifically designed for the complex, interconnected nature of the IoT era, including smart homes. Their implementation was a platform architecture model that aimed for extreme scalability while maintaining required performance. The article acknowledges the primary challenge as the advent of the complex IoT era, where all devices are interconnected, requiring enormous amounts of interaction. The article showcases a generic application, making extensive use of ports and adapters (hexagonal pattern) to integrate different data sources and data destinations, as well as third-party services, and by doing so, it presents solid foundation for a reference architecture pattern to be followed.

Jin \textit{et al}. \cite{jin_providing_2020} proposed the Peekaboo framework to provide architectural support for building privacy-sensitive smart home applications following homomorphic (a structure-preserving map between two algebraic structures of the same type) encryption of sensitive data. Their implementation philosophy moves pre-processing tasks (e.g., face detection) from the cloud onto a user-controlled hub. They achieved this by extracting image embeddings before sending data to the cloud. The authors primarily addressed the challenge of reducing data egress and minimizing potential privacy risks by preventing raw data from leaving the user's control. 

Khazbak \textit{et al}. \cite{khazbak_targetfinder_2020} designed TargetFinder, a system that finds targets using crowdsourced IoT camera videos while preserving privacy. Their implementation achieved privacy preservation by exploiting homomorphic encryption techniques, which allows a system to search for the target using encrypted information. The system also includes techniques to ensure the requester receives only images containing the target, thereby protecting bystanders' images. The authors faced the major challenge of high computation overhead from the cryptographic primitives, which required them to develop optimization techniques to run the protocol efficiently on mobile devices.

\section{Smart Scales}

The evolution of personal weighing devices from mechanical to electronic allow for better precision, ease of use and extra functionalities. The foundational technology of a modern electronic scale is a load cell, a transducer that converts mechanical force into an electrical signal. When an individual stands on the scale, a strain gauge undergoes a slight deformation. This deformation alters the electrical resistance of the gauge in a measurable way. An analog-to-digital converter processes this change, translating it into a precise digital weight value for display. While this technology significantly improved accuracy and usability over mechanical scales, its utility was confined to providing a single, instantaneous weight measurement.

The smart scale expands upon this foundation by integrating additional sensors and a communication module. These supplementary means provide a way to reshape the usage of a scale, or even add new functionality to it.

The connectivity of smart scales, typically through wireless protocols such as Bluetooth or Wi-Fi, is what defines their ``smart`` functionality. This capability facilitates the automatic and seamless transmission of collected data to a companion application or cloud-based service. This automated data flow eliminates the need for manual record-keeping, thereby supporting long-term, continuous health tracking. The compiled data can be visualized and analyzed over time, which supports a shift from reactive to preventive healthcare. 

The adoption of Smart Scales provide a number of benefits, such as easiest health tracking by health professionals and integration with other smart gadgets \cite{panja2025medical}. However, the adoption of this technology faces challenges. Research by Mafong \textit{et al}. \cite{mafong2020willing} indicates that while there is a general willingness to use smart scales, affordability remains a significant barrier for many consumers. The study found that a notable portion of potential users were unwilling or unable to purchase such a device, highlighting the need for cost-conscious development.

Hasti \textit{et al}. \cite{hasti_development_2025} developed an IoT-based digital weighing scale prototype to address the growing health concern of obesity. Their implementation utilized load cell sensors, an HX711 amplifier, and an ESP8266 microcontroller for weight measurement. A companion Flutter-based application (MyWeightApp) connected to Firebase provided data storage, visualization, and real-time tracking of Body Mass Index (BMI) calculation. The primary implementation challenge involved ensuring hardware accuracy; however, the authors' testing demonstrated a low 0.78 percent error rate, well within the tolerance threshold.

Jaiteh \textit{et al}. \cite{jaiteh_smart_2019} designed a multipurpose smart tracking system that functions as both a weighing scale and a human tracking system using gait analysis. The implementation featured a sensing platform built with eight load cells and an amplifier, which fed analog signals to an Arduino microprocessor for data processing, analysis, and representation. The authors powered the system with either a 9V battery or solar energy, indicating a focus on power efficiency and standalone operation. Their implementation focused on calibrating the load cells and testing the sensing platform's precision and accuracy against various static weights and different individuals.

Zargham \textit{et al}. \cite{zargham_revolutionizing_2023} introduced an Intelligent IoT-based Scale to automate the sales process for fruits and vegetables in small-scale retail. The implementation used a load cell with an HX711 amplifier for accurate weighing and integrated advanced computer vision using fine-tuned YOLOv5n and YOLOv7 models for item detection and identification. A Python script handled the pricing logic, and the authors developed a Graphical User Interface (GUI) for customer display and bill generation. The main implementation challenge was achieving high accuracy and efficacy in real-time processing. Still, their models achieved high mean Average Precision (mAP) scores (0.98 and 0.987) and high processing speeds.

\section{Privacy in IoT and Face recognition}

The explosive growth of the Internet of Things, particularly within the intimate setting of the smart home, has introduced a new and complex set of privacy and security challenges. Unlike traditional computing devices, IoT devices (also referred to as Smart Things) are often embedded into everyday objects, collecting vast amounts of granular, and often highly sensitive, personal data without the user's continuous, conscious interaction. This data can range from health metrics and daily routines to audio and video recordings captured by devices like smart speakers and cameras. The collection, transmission, and storage of this sensitive information create a vast surface area for potential security vulnerabilities and privacy breaches.

A central issue is the lack of privacy-by-design principles in many commercially available IoT devices and their corresponding development frameworks. This can lead to a host of security weaknesses, including weak authentication mechanisms, the transmission of unencrypted data, and an absence of user controls for managing personal information. The decentralized and heterogeneous nature of IoT ecosystems further complicates matters. A smart home can consist of devices from multiple manufacturers, each with its own security standards and data handling policies, making it difficult for a user to have a complete understanding and control over their data.

The use of biometric data, such as facial recognition in the context of the proposed Proof-of-Concept (PoC) smart scale, introduces a particularly acute privacy risk. If a biometric database is compromised, the user's identity is permanently at risk. This is a critical area that requires advanced security solutions. The work of Elordi \textit{et al}. \cite{elordi2021optimal} offers a compelling example of how to address this challenge. They propose a system that uses homomorphic encryption to protect this sort of data securely for elderly care applications. Homomorphic encryption allows computations to be performed on encrypted data without the need to decrypt it first. In the context of facial recognition, this means that the face matching process can occur on a server without the server ever having access to the unencrypted biometric template. This approach provides a powerful layer of privacy protection, as even if a database were to be breached, the data would remain encrypted. This PoC should build upon this by exploring secure data handling for facial recognition within a cost-conscious, smart home-oriented architecture, aiming to demonstrate how such advanced privacy measures can be integrated into a practical PoC.

\chapter{The Proof of Concept (PoC)}

This PoC consists of an embedded system with integrated sensors capable of weighing and identifying a subject alongside complementary services for face recognition and data storage. It also offers a simple dashboard interface for managing subject registration (referred as profiles) and visualizing available weight measurements of them realized with the sensor mentioned.

This section unfolds the details of designing and implementing the whole system and presents the decision process for every step and piece of it.

The system consists of three layers: the edge, the fog, and the cloud or application layer. The edge layer consists of a scale, an HX711 signal amplifier and an ESP32. The scale itself consists of a Wheatstone bridge built with straing gauge load cells, connected using standard copper wires. The load cells are then connected to an HX711 signal amplifier that is then connected to the ESP32.

The ESP32 is callibrated using known weights and programmed to poll variations in voltage caused by deformation of the strain gauges when a weight is placed on top of them. The ESP32 module comes with a camera that captures image once a given weight threshold is beated.

The calibration is done through the polynomial regression of the acquired ADC (voltage) value and respective known weight values, resulting in a curve that is used to map ADC values to weight measurements.

[TODO add here image of the curve and table of the values]

Both image feature vector and weight value are sent to an MQTT broker, which serves as a queue service. For the purpose of this PoC, the broker was set up in a personal computer and executed under a \textbf{docker container} for abstraction, but it could be deployed to a RaspberryPi or even another ESP32 for its lightweight nature. 

The fog layer consists of the MQTT broker which acts as the gateway between the embedded system and its gathered data users (cloud layer services). Nevertheless, the cloud layer includes both a Hub Service for managing measurements in the database and a dashboard for visualizing available measurements by profile as shown in \ref{fig:dashboard}\index{dashboard}.

\begin{figure}[ht]
  \caption{Dashboard overview}
  \centering
  \includegraphics[scale=0.3]{dashboard}
  \label{fig:dashboard}
\end{figure}

\section{Project specification}
\subsection{Functional Requirements}

The functional requirements (FRs) for the system define what it does from certain actor perspectices. The following functional requirements were identified:

\begin{enumerate}
  \item The user shall be able to create profiles through a frontend client
  \begin{enumerate}
    \item When creating a profile the user shall be able to name the profile
    \item When creating a profile the user shall be able to send a picture to be used for face recognition of the subject related to that profile
  \end{enumerate}
  \item The user shall be able to access the available profiles and their available measurements
  \item The user shall be able to measure their weight by stepping up on the scale when stepping up on the scale the system should then use its camera to match the subject.
\end{enumerate}

\subsection{Nonfunctional Requirements}

Nonfunctional Requirements (NFRs) layout the qualities of a system, or \textit{how} it should perform its functionalities. For this PoC, the following NFR were set:

\begin{enumerate}
  \item The weight measurement must be accurate within an 100 grams margin of error;
  \item The system shall account for measurement or face matching errors and support retry policies;
  \item The system must be easily extensible to consider the possible adition of extra sensors and connection to outside systems;
  \item Privacy is paramount and sensitive data such as biometric data shall never be saved in its raw format.
\end{enumerate}

\section{PoC Overview}

In order to accomodate the FRs and NFRs, many engineering decisions were made based on literature review and good practices in software engineering and architecture. The embedded system is an ESPCAM (an ESP32 with built-in camera and SD card support) and its software was written in C, using Espressif libraries for MQTT and TensorFlow Lite pre-trained models for extracting  face feature vectors from camera imaging. The MQTT broker is the Mosquitto by Eclipse implementation. Within the cloud layer, the data storage is implemented using PostgreSQL running pgvector plug-in for ease querying and storage of feature vectors. Still within the cloud layer, the Hub Service is implemented following the hexagonal architectural pattern and uses Kotlin with the Spring Boot framework for providing a web API and an MQTT client. Finally, we implemented a dashboard for easier visualization of the measurements. Figure \ref{fig:overview} shows an overview of the whole solution. Notice in the figure \textbf{MobileApp} is not part of this PoC, but it exemplifies how the system could be easily extended. Other extensions to the system will be discussed in the Discussion section of the Conclusion chapter.

\begin{figure}[ht]
  \caption{System overview and communication routes}
  \centering
  \includegraphics[scale=0.2]{overview}
  \label{fig:overview}
\end{figure}

\section{PoC edge layer}

The \textbf{edge layer} contains the embedded solution with a weight sensor and a camera attatched to it. The solution was developed using an ESP32 microcontroller embedded with a 2 megapixel camera (ESPCAM), alongisde an HX711 signal amplifier chip. The weight sensor consists of a Wheatstone Bridge constructed with four strain gauges. Figure \ref{fig:wheatstone}\index{wheatstone} shows how the Wheatstone bridge is created, the resulting system allows for measurement of up to 200Kg of weight. Figure \ref{fig:physical}\index{physical} shows the actual load cell layout in the PoC.

TODO add image here for the conceptual wheatstone
TODO take picture and add image here for actual load cell layout

The ESP32 is aware of voltage variation to infer weight values based on callibrated reference values. Once a threshold is perceived, the camera is activated and an image is taken of the subject being weighed. Both weight and image information are sent to an MQTT broker that belongs to the next layer, the \textbf{fog layer}.

The callibration of the system was made through the measurement of voltage for known weight values by gradatively adding water to a bottle, measuring its weight with a kitchen scale and then measuring the difference in voltage perceived by the microcontroller. Those values are then fit to a curve through polynomial regression. The resulting sum of powers defines the function that maps ADC (Analog to Digital Converter) voltage read values to weight values.

TODO add table here with the values
TODO add image here with the resulting graph

Once the weight beats a given threshold of 5 grams the scale is set to retire from its idle state and take a picture of the subject on it. The microcontroller makes use of the pre-trained MobileFaceNet model from TensorFlow Lite library to extract the feature vector from the image. By doing so, the subject image never leaves the \textbf(edge layer) and thus their privacy is protected by avoiding the transmission of possible sensitive biometric data to the \textbf{cloud layer}. Still, this feature vector is enough to query registered profiles in the database and follows the homomorphic encryption approach \cite{jin_providing_2020}. Figure \ref{fig:stateesp}\index{stateesp} shows the state machine representation of the ESP32 microcontroller workflow. While on an idle state, a disruption of the weight on the scale wakes it up to start the measuring process explained before.

\begin{figure}[ht]
  \caption{State Machine Diagram of the ESP32 workflow}
  \centering
  \includegraphics[scale=0.2]{stateesp}
  \label{fig:stateesp}
\end{figure}

TODO add image of the espcam face recon feature for representation of what happens

\section{PoC fog layer}

The \textbf{fog layer} consists of the intermediate services and tools for the system to work, however it still remains within the household domain. This means information here is still private to the local network (LAN). This layer can be deployed to serve as an IoT Hub for smart things in the house to communicate between themselves.

Within this project, this layer contains an \textbf{MQTT Broker}, which acts as a queue service bridging the edge and cloud layers. This is done by representing tasks as events to be parsed and reacted upon by the other layers.
Therefore, the MQTT Broker serves as a queue service for bridging the edge layer to its required services. 

In this schema, the ESP32 \textit{publishes} a message to the broker as a \textbf{MeasurementTakenUnprofiled} event, which contains a \textbf{topic} name, a weight value and a vector of embeddings. The topic represents something similar to a table in a DBMS (Database Management System) and is used to separate event contexts. Consequently, the HubService \textit{consumes} the message and attempts to find the closer vector in the database and sends back a \textbf{MeasurementRegisteredProfiled} event so that the EPS32 is made aware everything went as expected. If the image does not match any registed profile, then the ESP32 is notified through the publishing of an \textbf{MeasurementFailedUnprofiled} event in the MQTT broker. Figure \ref{fig:flowchart}\index{flowchart} shows a simplified event flowchart for the system.

\begin{figure}[ht]
  \caption{Simplified event flowchart}
  \centering
  \includegraphics[scale=0.2]{flowchart}
  \label{fig:flowchart}
\end{figure}

\begin{figure}[ht]
  \caption{Event Flow when face is recognized}
  \centering
  \includegraphics[scale=0.2]{eventflowok}
  \label{fig:eventflowok}
\end{figure}

This workflow follows and Event-Driven Architecture (EDA) and is made possible through the definition of topics within the MQTT broker. Figure \ref{fig:eventflowok}\index{eventflowok} and {fig:eventflownotok}\index{eventflownotok} show the event flows for this subsystem of the PoC. Each event is always sent to its own topic, and services subscribe and publish to their topics of concern as Figure \ref{fig:mqttbroker}\index{mqttbroker} shows.

\begin{figure}[ht]
  \caption{Event Flow when face is not recognized}
  \centering
  \includegraphics[scale=0.2]{eventflownotok}
  \label{fig:eventflownotok}
\end{figure}

\begin{figure}[ht]
  \caption{MQTT Broker Topics and workflow}
  \centering
  \includegraphics[scale=0.05]{mqttbroker}
  \label{fig:mqttbroker}
\end{figure}

\section{PoC cloud layer}

The \textbf{cloud layer} is comprised of the HubService and a PostgreSQL database for storing profiles, their face embeddings and their measurements. The HubService is implemented following the Hexagonal Architectural Pattern and consists of an API for managing accessing database records and an MQTT client to consume and publish events to the MQTT broker in the \textbf{fog layer}. For this PoC, a dashboard serves as an example application of how the system could be used. The dashboard serves for managing profiles and visualizing the measured weights for them.

The database is designed to be simple and yet efficient, storing data in three tables: \textbf{profile}, \textbf{profile measurement}, and \textbf{profile embedding}. The \textbf{profile} table stores scale users information and identifies them with an UUID (Universally unique identifier). The \textbf{profile measurement} records holds a reference id to the profile they belong to and the weight measurement value. Finnaly, the \textbf{profile embedding} table stores available feature vectors for a profile to be used by face matching algorithms. PostgreSQL is set up with the \textbf{pgvector} plug-in that allows for the storage and retrieval of vector types in an efficient manner.

TODO inserir imagem do schema do banco aqui

The HubService in its turn is implemented in Kotlin using the Spring Boot framework, which contains REST and MQTT abstraction layers for an easier implementation of those services. The Gradle build tool is used for faster deployment of the system and both the database and the service are contained in docker containers.

The REST API serves endpoints for managing profiles, which includes creating, updating, and deleting profiles, as well as reading the available ones in the database. The API also contains two extra endpoints for adding new embeddings to a profile and for retrieving the measurements of a profile.

Alongside the REST API, the Dashboard allows for using the API through a graphical user interface (GUI). Even though it is simple, it lets the scale users follow up all measurements available per profile. Figure \ref{fig:dashboard} shows the dashboard landing page. 

\begin{figure}[ht]
  \caption{Dashboard overview}
  \centering
  \includegraphics[scale=0.3]{dashboard}
  \label{fig:dashboard}
\end{figure}

//aqui seguir explicando todos os caminhos de uso do dashboard e colocando os prints

TODO add Swagger screenshot and list of endpoints

//aqui explicar o caminho pelo qual os measurements chegam ao database por meio do mqtt adapter

\section{Smart Scale Face Recognition}

The Face Recognition aspect of the system has its complexities of its own. Specially, the set privacy concerns required novel solutions. The images used for profile matching are never stored in order to keep privacy untouched.

The project uses an homomorphic encryption approach in which the feature vector of the system is used to represent it. This method allows for searching and comparing images without the raw data.

This is made possible through the usage of the pgvector plugin within the PostgreSQL database used. It allows for storage and query of vector, which eases the process of matching profiles to weighing subjects.

Therefore, both during the registration of a profile and the taking of an image by the ESP32, the image embeddings are taken and used in place of the raw image data. This way biometric information is never stored, and is not kept in the \textbf{cloud layer}.

\section{Project Evaluation}

The PoC was evaluated in terms of how well the novel approaches proposed in literature could actually be implemented. More than that, we evaluate the face matching performance when using light pre-trained models that can run on an ESP32 and the overrall performance of the system by measuring latency of data flow across the whole solution.

In order to measure face matching performance we compare different lighting conditions and percentage of retry request events in the communication between edge layer and cloud layer through the MQTT broker. Besides that, for performance we consider the different time values that are created for measurements, being those: measurement time (the moment the ESP32 sends the event with the measured value); record time (the moment the measurement is recorded in the database); and creation time (the moment the measurement is consumed and internalized in the HubService). Nevertheless, those KPIs (Key Performance Indicators) combined serve the purpose of evaluating the feasability and aplicability of the novel approaches gathered in the theorical foundation.

\phantompart

% ---
% Conclusão
% ---
\chapter{Conclusion}
\section{Contributions}
\section{Discussion}
\section{Future work}
Applications to the Internet of Medical Things
Applications to Husbandry
% ---
% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
% Retire o comentário somente se o padrão exigir que daqui para a
% frente não haja número de páginas.
%\postextual
% ----------------------------------------------------------

% ------
\bibliography{refs.bib}
% ------

%---------------------------------------------------------------------
% INDICE REMISSIVO
%---------------------------------------------------------------------
\phantompart
\printindex
%---------------------------------------------------------------------
\end{document}
