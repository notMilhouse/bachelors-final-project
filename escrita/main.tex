\documentclass[
12pt,        % tamanho da fonte
openright,   % capitulos comecam em paginas impares, insere paginas em branco se necessario
twoside,     % para impressao frente e verso, comente esta linha se for imprimir só frente.
a4paper,     % tamanho do papel
% -- opções da classe abntex2 -- retire o comentario para obter o comportamento
% chapter=TITLE,         % títulos de capítulos convertidos em letras maiúsculas
% section=TITLE,         % títulos de seções convertidos em letras maiúsculas
% subsection=TITLE,      % títulos de subseções convertidos em letras maiúsculas
% subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
% -- opções do pacote polyglossia --
% french,      % idioma adicional para hifenizacao
% spanish,     % idioma adicional para hifenizacao
brazil,       % idioma adicional para hifenizacao
english       % ultimo idioma eh o principal do documento
%
% ppgca.cls options
%
,englishwr      % For documents written in english, remove only the coment '%'
]{ppgca}

\usepackage{booktabs} % For professional-looking tables (\toprule, \midrule, \bottomrule)
\usepackage{siunitx}  % For aligning numbers (especially with decimal points, though not strictly needed here)
\usepackage{amsmath}  % For ensuring math environments work if needed
\usepackage{color,listings}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\newsavebox\lstbox

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para que o primeiro parágrafo também seja 'indentado':
% troque \ifnum1=0 por \ifnum1=1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifnum1=0
\ifxetexorluatex
\PolyglossiaSetup{brazil}{indentfirst=true}
\PolyglossiaSetup{english}{indentfirst=true}
\else
\usepackage{indentfirst}
\fi
\fi

\graphicspath{ {./images/} }

%%%%%%%%%%%%%%%% VERSÃO DO DOCUMENTO: ORIGINAL OU CORRIGIDA
% Após as correções sugeridas pela banca serem efetuadas, retire os comentários
% da próxima linha.
%\versaodocumento{corrigida}

% Este arquivo foi baseado no modelo disponível em https://www.ctan.org/pkg/abntex2.

% Para gerar o indice, execute o comando makeindex:
% makeindex main

% O preambulo deve conter o tipo do trabalho, o objetivo,
% o nome da instituição e a área de concentração
\preambulo{Final Paper for the Bachelor in Computer Science program under Departamento de Computação e Matemática of the Universidade de São Paulo}

\usepackage{blindtext}

%---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\title{An IoT Smart Scale Proof of Concept \\ for Smart Homes}
\author{Gabriel Carvalho Silva}
\local{Ribeirão Preto--SP}
\data{2025}
\orientador{Cléver Ricardo Guareis de Farias}
\coorientador{}
\tipotrabalho{Final Paper} % Dissertação ou Tese

% ---
% Espaçamentos entre linhas e parágrafos
% ---
% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

%#% you can change the language used (brazil) by set and uncomment the
%#% following command:
% \setdefaultlanguage{english}

% #% Options for the \setdefaultlanguage{} can be found at
% #% http://mirrors.ctan.org/macros/latex/contrib/polyglossia/polyglossia.pdf#page=5

% ---
% ---
% compila o indice
% ---
\makeindex
% ---
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para limpar o cabeçalho, troque \ifnum1=0 por \ifnum1=1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifnum1=0
\newcommand{\sectionbreak}{\clearpage
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}
\fi

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% ---
% Capa
% ---
\imprimircapa
% ---

% ---
% Folha de rosto
% (o * indica que haverá a ficha bibliográfica)
% ---
% \imprimirfolhaderosto
% ---

%---
% Imprime a folha de rosto em inglês (Opcional)
\coversheet{An IoT Smart Scale Proof of Concept for Smart Homes}
%---


% ---

% ---
% Inserir errata
% ---
% \begin{errata}
% Elemento opcional da NBR14724:2011. Exemplo:

% \vspace{\onelineskip}

% FERRIGNO, C. R. A. \textbf{Tratamento de neoplasias ósseas apendiculares com
% reimplantação de enxerto ósseo autólogo autoclavado associado ao plasma
% rico em plaquetas}: estudo crítico na cirurgia de preservação de membro em
% cães. 2011. 128 f. Tese (Livre-Docência) - Faculdade de Medicina Veterinária e
% Zootecnia, Universidade de São Paulo, São Paulo, 2011.

% \begin{table}[htb]
% \center
% \footnotesize
% \begin{tabular}{|p{1.4cm}|p{1cm}|p{3cm}|p{3cm}|}
%   \hline
%    \textbf{Folha} & \textbf{Linha}  & \textbf{Onde se lê}  & \textbf{Leia-se}  \\
%     \hline
%     1 & 10 & auto-conclavo & autoconclavo\\
%    \hline
% \end{tabular}
% \end{table}

% \end{errata}
% ---

% ---
% Inserir folha de aprovação
% ---

% Isto é um exemplo de Folha de aprovação, elemento obrigatório da NBR
% 14724/2011 (seção 4.2.1.3). Você pode utilizar este modelo até a aprovação
% do trabalho. Após isso, substitua todo o conteúdo deste arquivo por uma
% imagem da página assinada pela banca com o comando abaixo:
%
% \begin{folhadeaprovacao}
% \includepdf{folhadeaprovacao_final.pdf}
% \end{folhadeaprovacao}
%
% \begin{folhadeaprovacao}

%   \begin{center}
%     {\theauthor}

%     \vspace*{\fill}\vspace*{\fill}
%     \thetitle
%     \vspace*{\fill}

%     \hspace{.45\textwidth}
%     \begin{minipage}{.5\textwidth}
%         \imprimirpreambulo
%     \end{minipage}%
%     \vspace*{\fill}
%    \end{center}

%    Trabalho aprovado. \imprimirlocal, 21 de novembro de 2018:

%    \assinatura{\textbf{\thesupervisorlabel:} \\ Orientador}
%    \assinatura{\textbf{Professor} \\ Convidado 1}
%    \assinatura{\textbf{Professor} \\ Convidado 2}
%    \ifthenelse{\equal{\imprimirtipotrabalho}{Tese}}{
%      \assinatura{\textbf{Professor} \\ Convidado 3}
%      \assinatura{\textbf{Professor} \\ Convidado 4}
%    }{}

%    \begin{center}
%     \vspace*{0.5cm}
%     {\large\imprimirlocal}
%     \par
%     {\large\imprimirdata}
%     \vspace*{1cm}
%   \end{center}

% \end{folhadeaprovacao}
% ---

% ---
% Dedicatória
% ---
\begin{dedicatoria}
   \vspace*{\fill}
   \centering
   \noindent
   \textit{A minha avó, Maria Daria Rocha, e ao Gabriel que escrevia códigos no papel.} \vspace*{\fill}
\end{dedicatoria}
% ---

% ---
% Agradecimentos
% ---
\begin{agradecimentos}
I would like to express my deepest gratitude to my advisor, PhD. Cléver Ricardo Guareis de Farias, for their continuous support and patience.

My sincere appreciation also goes to the University of São Paulo for providing me with unique opportunities. All the experience I gathered while a student there cannot be measured.

I appreciate my mom, Rozirene Rocha de Carvalho for doing the best she could, she is a superhero, and I appreciate my grandparents and grandmothers, for teaching me affection. I appreciate my family as a whole for showing me what to be and what not to become.

I appreciate all the hardships encountered along the way, and all the good fortune that crossed my path until here. The good and the bad made me who I am, and I am specially grateful for the rejections and failures because they taught me my limits and they guide me to where I belong.

I am grateful for having wonderful friends, and I am specially grateful for Carla de Araújo Clementino Ribeiro and Matheus Sampaio Lopes, the two best friends anyone could ever hope for.

Thank you to all my teachers, professors, tutors, mentors, and any other sort of educator I found in life.

Thank you to my godfather and godmother for being as present in my life as it was humanly possible and thank you to my brother for never ever letting me give up.

Finally, I must express my very profound gratitude to my partner, Beatriz de Souza Silva, for providing me with unbelievable support and continuous encouragement daily, and to my father, MSc. Wilbert Carpi Silva, who taught me my very first lines of code through a telephone. This accomplishment would not have been possible without them.
\end{agradecimentos}
% ---

% ---
% Epígrafe
% ---
\begin{epigrafe}
    \vspace*{\fill}
        \begin{flushright}
                \textit{``E ao vencedor, as batatas '' \\
                          (Quincas Borba)}
        \end{flushright}
\end{epigrafe}
% ---

% ---
% RESUMOS
% ---

% resumo em português
% remover se o documento for em inglês
% \setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo
% \begin{resumo}
%   Este documento é um modelo \LaTeX para servir como base para edição
%   de uma dissertação a ser apresentada ao programa de pós-graduação em
%   Computação Aplicada do Departartamento de Computação e Matemática da
%   FFCLRP/USP.

% \noindent \textbf{Palavras-chave}: latex. abntex. editoração de texto.
% \end{resumo}

% resumo em inglês
\begin{resumo}[Abstract]
% \begin{otherlanguage*}{english}
This document describes the development of an Internet of Things (IoT) smart scale proof-of-concept (PoC) for smart home integration. The motivation for this work is to address key barriers to adoption in the field, specifically high costs, privacy concerns, and system scalability. This project aims to build a custom architectural solution to demonstrate a cost-conscious, privacy-by-design approach. The developed system consists of an embedded scale with facial recognition capabilities, a service layer for data management, and a client dashboard for data visualization and configuration. The design emphasizes an event-driven architecture using Message Queuing Telemetry Transport (MQTT) to ensure efficient and adaptive communication. Ultimately, this PoC will serve as a practical demonstration of best practices in the design of IoT systems and of the application of novel approaches in edge computing, offering valuable insight into interoperability and performance trade-offs for smart home health devices.

\vspace{\onelineskip}

\noindent \textbf{Keywords}: Internet of Things (IoT), Smart Homes, Embedded Systems, Facial Recognition, Adaptive Systems, Event-driven Architecture, MQTT, Proof-of-Concept
% \end{otherlanguage*}
\end{resumo}

% OBS: A numeração de páginas deve sempre começar em páginas ímpares,
% por isto o uso de \cleardoublepage.

% ---
% inserir lista de figuras
% ---
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\cleardoublepage
% ---

% ---
% inserir lista de quadros (opcional)
% ---
% \pdfbookmark[0]{\listofquadrosname}{loq}
% \listofquadros*
% \cleardoublepage
% ---

% ---
% inserir lista de tabelas
% ---
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\cleardoublepage
% ---

% ---
% inserir lista de abreviaturas e siglas
% ---
\begin{siglas}
  \item [ADC] Analog to Digital Converter
  \item [BMI]	Body Mass Index
  \item [DBMS] Database Management System
  \item [EDA] Event-Driven Architecture
  \item [FR] Functional Requirement
  \item [GUI]	Graphical User Interface
  \item [HePA] Hexagonal Platform Architecture
  \item [HTTP] Hypertext Transfer Protocol
  \item [IoT] Internet of Things
  \item [KPI] Key Performance Indicator
  \item [LAN]	Local Area Network
  \item [mAP] mean Average Precision	
  \item [MQTT] Message Queuing Telemetry Transport
  \item [NFR] Nonfunctional Requirement
  \item [PoC] Proof-of-Concept
  \item [REST] Representational State Transfer
  \item [TCP/IP] Transmission Control Protocol/Internet Protocol
  \item [UUID] Universally Unique Identifier
\end{siglas}
% ---

% ---
% inserir o sumario
% ---
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---
% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual
\setcounter{page}{1}
\chapter{Introduction}
\section{Background}

The history of the Internet is a story of continuous expansion and integration. Starting in the late 1960s with ARPANET, a network for government and academic use, it was a tool for sharing information across an enclosed group of institutions and people. The adoption of the TCP/IP protocol in the early 1980s and the birth of the World Wide Web in the 1990s democratized this connectivity, paving the way to a modern digital world. Moreover, with the rise of affordable sensors, ubiquitous wireless technologies like Wi-Fi and 5G, and the vast processing power of cloud computing, the Internet's reach extended beyond traditional computers to encompass everyday objects. This transformation allowed devices to collect, share, and act on data autonomously, laying the groundwork for a ``network of things'', or Internet of Things (IoT). This transformation has been particularly impactful in the healthcare domain, where everyday devices have evolved from simple measurement tools into interconnected monitoring systems. 

Internet-connected things include thermostats that can be controlled remotely from smartphones and smart body scales that allow one to graphically review the progress of diets using smartphones, for example. Moreover, smart scales detect gradual weight changes and, when integrated with smart home systems, create comprehensive health monitoring environments. This continuous data stream allows, for example, for healthcare agents to intervene earlier and more precisely, potentially reducing hospital admissions and healthcare costs \cite{panja2025medical}.

However, despite the increasing interest in IoT, the development of cost-effective IoT solutions currently face many different challenges. For instance, privacy features in many existing IoT development frameworks are relatively limited \cite{jin2020privacy}, which affects, for example, smart scale solutions reliability. Besides that, handling IoT sensor data, especially in terms of processing and integration with other data sources, has its own setbacks \cite{challenges2024nwamaka}. Likewise, there is no ground truth for project design and architecture, which raises the question of which service composition mechanism best fulfills the functional scalability requirements of IoT systems \cite{evaluation2020kung}. On top of that, buying a scale can be financially challenging, particularly for low-income individuals, and scales with advanced features cost significantly more than scales without these features \cite{affordability2021park}.

\section{Objective}

Within this context, and specifically to address the barriers of cost, privacy, and scalability identified above, this project aims to deliver a working prototype of a smart scale with face recognition capability. Therefore, it consists of an embedded system for weighing a subject and capturing their face image, a web service for managing weight records and performing face recognition, and a dashboard for measured data visualization. 

The development of the Proof-of-Concept (PoC) system takes into account cost and privacy concerns, as well as system scalability, considering different possible architecture styles \cite{dimartino2018iot}. It also explores and validates different aspects of such a system and their specific challenges following novel approaches from literature.

\section{Methodology}

This work followed the literature review to guide the understanding of current state of the art regarding IoT Systems, specially related to smart scales and privacy-aware scopes. Therefore, in order to follow up with the design and implementation of the system and subsequent evaluation of it, we opted for the ESP32 \cite{esp32} (the ESPCAM model specifically) as an accessible option for hardware solution and set a requirement for ESP32 compliant face embeddings extraction methods. Not only that, the architecture was defined by considering simplicity and extensibility capabilities besides functional requirements.

Several architectural styles were considered from current state of the art \cite{dimartino2018iot}, leading to the adoption of a reactive event-driven architecture. This decision is aligned with the nature of the expected functionality of a smart scale, in which retry policies were implemented for when face recognition failed, and in which system components can be decoupled for extensibility.

Therefore, the ESP32 was calibrated for weight measurement and implemented the face embedding extraction using pre-trained models, an event queue was used to bridge system components, a web service was developed to manage data acquisition and retrieval and a dashboard was also created to visualize weight measurements.

Finally, the usage of the system as a whole was put under daily tests leading to conclusions regarding the actual feasability of the solutions for the challenges concerning cost, privacy and performance.

\section{Structure of the document}

The following chapters explore in more depth the various aspects of this project: Chapter 2 reviews literature and related work; Chapter 3 details the PoC development; and Chapter 4 brings to light the findings of this project.

\chapter{Theoretical Foundation}
\section{Internet of Things}

The Internet of Things (IoT) can be defined as an open and comprehensive network of intelligent objects that have the capacity to organize themselves, share information, react and act in situations faced and changes in the environment \cite{somayya2015smart}. IoT consists of an inter-network of physical devices like vehicles, buildings, and other items embedded with electronics, sensors, actuators, software, and network connectivity that allow these objects to collect and exchange data \cite{mehra2019home}. 

Naturally, communication is a key layer upon which any IoT solution is built and it involves a careful consideration of both the physical infrastructure and the logical architecture. At the physical layer, devices need to communicate wirelessly, and the choice of technology depends heavily on the specific application's requirements for bandwidth, range, and power consumption. For example, Wi-Fi is a common choice for many smart home devices due to its high bandwidth, which is essential for data-intensive tasks like streaming video from a security camera, and its widespread availability. However, Wi-Fi is also relatively power-intensive, which is a major drawback for battery-operated devices that need to run for months or years without a charge \cite{mocrii2018sys}.

In contrast, Bluetooth, and its more energy-efficient variant, Bluetooth Low Energy \cite{bluetooth}, is optimized for low-power, short-range communication, making it an ideal choice for wearable devices, fitness trackers, and other battery-powered sensors. Still, other emerging technologies such as LoRa \cite{lora}, which is specifically designed for long-range, low-power communication, are more suited for applications in smart cities or large-scale industrial IoT, as highlighted by Kane \textit{et al}. \cite{kane2022lora}. 

Beyond the physical layer, the logical architecture of communication is crucial to ensuring scalability, efficiency, and responsiveness in a heterogeneous IoT environment. The traditional request-response model, often implemented via HTTP/REST API calls, is a synchronous pattern in which a client sends a request to a server and waits for a response. This model is well-suited for many web applications but can be inefficient in an IoT context where devices may be intermittently connected and need to send data proactively rather than waiting for a request. 

A more robust and scalable solution for IoT is an event-driven architecture (EDA). According to this paradigm, devices and services operate asynchronously, communicating through the publication and subscription of ``events.'' For example, when a user steps on the scale, the embedded system publishes a ``weight-measured'' event to a central message broker. Other services, such as a data processing worker or the face recognition service, that are interested in this event are automatically notified.

This publish-subscribe model, which is often facilitated by a lightweight messaging protocol such as Message Queuing Telemetry Transport (MQTT) \cite{mqtt}, is highly advantageous for IoT systems. MQTT is designed for resource-constrained devices and low-bandwidth, high-latency networks, making it an ideal fit for the project. An EDA allows for loose coupling between components, meaning a new device or service can be added to the system without requiring changes to existing components. This modularity is a key factor for scalability and adaptability. In addition, it enables adaptive, context-aware data acquisition strategies. 

In a system with low-frequency sensor data (weight) and high-latency operations (image processing for facial recognition), an event-driven model can optimize bandwidth and energy consumption. The system can be configured to only publish data when a significant change occurs (e.g., a weight measurement crosses a certain threshold) or when a specific condition is met, avoiding the need for continuous, wasteful polling. This adaptive approach is central to the proposed system's design, aiming to improve responsiveness and reduce resource consumption in a real-world smart home environment.

\section{IoT Sensors}

While the communication infrastructure enables IoT devices to exchange information, the actual data acquisition depends on the sensors embedded within these devices. IoT devices are also called Smart Things, which can also be perceived as physical objects connected to the web with some sensing capabilities \cite{somayya2015smart}. Sensing is made possible by pairing embedded devices with sensors, actuators and other sorts of appendixes. Sensor are crucial for acquiring data and providing context for the interoperability of different IoT devices \cite{panja2025medical}. 

Sensors can be of many kinds and serve many purposes. Temperature, umidity and proximity sensors are some examples of it. Weight sensors specifically are commonly a composiiton of load cells. The most widely used load cell is the strain gauge which is a thin foil resistor that alters the voltage as it is strained, hence its name. Strain gauges measure variations in voltage once they are deformed, because the intensity of the electrical resistance variation in the strain gauges is proportional to the intensity of the applied force that deform them \cite{muller_load_2010}. This is paramount for IoT systems due to its simplicity and several application possibilities.

\section{IoT System Architectural Styles}

Figure \ref{fig:mocrii}\index{mocrii} shows a simplification of an IoT architecture. Each and every component of this diagram is an essential part of most IoT systems. In the edge layer, sensors (devices that transforms physical action in data), actuators (devices that transform energy into a physical action) and other smart appliances work together to gather important data and react to what is perceived in the environment. In order to scale that, however, and provide even more possibilities, cloud solutions integrate with the edge devices to achieve an ubiquitous experience. This integration is only possible through the implementation of bridges, such as network gateways, queue services, intermediate services, all those which constitute what is called a fog layer \cite{mocrii2018sys}.  

Still, different architectural approaches shift focus through the layers, putting more emphasis in one or another depending on the goal in mind and the applications desired. The cloud computing approach offers high processing power and storage option, while edge computing is more limited when it comes to computing power. However, edge computing achieves privacy measures more easily than the cloud. Nevertheless, fog computing is another approach that takes processing power closer to embedded devices on the edge, while still keeping the cloud layer unware of sensitive information. Therefore, depending on the goals for a project, the placement of system components and tasks should be placed accordingly to what every computing layer offers and limits. This PoC focuses on the edge layer as an enabler for private interactions with smart gadgets.

\begin{figure}[H]
  \caption{Generic IoT Architecture.}
  \centering
  \includegraphics[width=0.90\textwidth]{mocrii}\\
  \textbf{Source: Author}
  \label{fig:mocrii}
\end{figure}

\section{Smart Homes}

A smart home system forms when interconnected devices, embedded with electronics, sensors, software, and network connectivity, work within a household. Mocrii \textit{et al}. \cite{mocrii2018sys} define this system as having complementary user and system functions built upon a general IoT-based architecture. The devices themselves carry embedded intelligence, identification, and automation capabilities designed to assist human life.

Seo \textit{et al}. \cite{seo_hepa_2015} proposed the Hexagonal Platform Architecture (HePA) as a reference architecture specifically designed for the complex, interconnected nature of the IoT era, including smart homes. Their implementation was a platform architecture model that aimed for extreme scalability while maintaining required performance. The authors acknowledges the primary challenge as the advent of the complex IoT era, where all devices are interconnected, requiring enormous amounts of interaction. Further, they showcase a generic application, making extensive use of ports and adapters (hexagonal pattern) to integrate different data sources and data destinations, as well as third-party services, and by doing so, it presents solid foundation for a reference architecture pattern to be followed.

Jin \textit{et al}. \cite{jin_providing_2020} proposed the Peekaboo framework to provide architectural support for building privacy-sensitive smart home applications following homomorphic (a structure-preserving map between two algebraic structures of the same type) encryption of sensitive data. Their implementation philosophy moves pre-processing tasks (e.g., face detection) from the cloud onto a user-controlled hub. They achieved this by extracting image embeddings before sending data to the cloud. The authors primarily addressed the challenge of reducing data egress and minimizing potential privacy risks by preventing raw data from leaving the user's control. 

\section{Smart Scales}

The evolution of personal weighing devices from mechanical to electronic allowed for better precision, ease of use and extra functionalities. The foundational technology of a modern electronic scale is a load cell, a transducer that converts mechanical force into an electrical signal. When an individual stands on the scale, a strain gauge undergoes a slight deformation. This deformation alters the electrical resistance of the gauge in a measurable way. An analog-to-digital converter processes this change, translating it into a precise digital weight value for display. While this technology significantly improved accuracy and usability over mechanical scales, its utility was confined to providing a single, instantaneous weight measurement.

The smart scale expands upon this foundation by integrating additional sensors and a communication module. These supplementary means provide a way to reshape the usage of a scale, or even add new functionality to it.

The connectivity of smart scales, typically through wireless protocols such as Bluetooth or Wi-Fi, is what defines their ``smart'' functionality. This capability facilitates the automatic and seamless transmission of collected data to a companion application or cloud-based service. This automated data flow eliminates the need for manual record-keeping, thereby supporting long-term, continuous health tracking. The compiled data can be visualized and analyzed over time, which supports a shift from reactive to preventive healthcare.   

The adoption of Smart Scales provide a number of benefits, one of which being the possibility for health professionals to remotely track health indicators of their patients. Allied with other smart gadgets, severe health issues can be avoided such as heart attacks \cite{panja2025medical}. Neverheless, the adoption of this technology faces challenges. Research by Mafong \textit{et al}. \cite{mafong2020willing} indicates that while there is a general willingness to use smart scales, affordability remains a significant barrier for many consumers. The study found that a notable portion of potential users were unwilling or unable to purchase such a device, highlighting the need for cost-conscious development.

Hasti \textit{et al}. \cite{hasti_development_2025} developed an IoT-based digital weighing scale prototype to address the growing health concern of obesity. Their implementation utilized load cell sensors, an HX711 \cite{hx711} amplifier, and an ESP8266 microcontroller for weight measurement. A companion Flutter-based application (MyWeightApp) connected to Firebase provided data storage, visualization, and real-time tracking of Body Mass Index (BMI) calculation. The primary implementation challenge involved ensuring hardware accuracy; however, the authors' testing demonstrated a low 0.78 percent error rate, well within the tolerance threshold.

Jaiteh \textit{et al}. \cite{jaiteh_smart_2019} designed a multipurpose smart tracking system that functions as both a weighing scale and a human tracking system using gait analysis. The implementation featured a sensing platform built with eight load cells and an amplifier, which fed analog signals to an Arduino microprocessor for data processing, analysis, and representation. The authors powered the system with either a 9V battery or solar energy, indicating a focus on power efficiency and standalone operation. Their implementation focused on calibrating the load cells and testing the sensing platform's precision and accuracy against various static weights and different individuals.

Zargham \textit{et al}. \cite{zargham_revolutionizing_2023} introduced an Intelligent IoT-based Scale to automate the sales process for fruits and vegetables in small-scale retail. The implementation used a load cell with an HX711 amplifier for accurate weighing and integrated advanced computer vision using fine-tuned YOLOv5n and YOLOv7 models for item detection and identification. A Python script handled the pricing logic, and the authors developed a Graphical User Interface (GUI) for customer display and bill generation. The main implementation challenge was achieving high accuracy and efficacy in real-time processing. Still, their models achieved high mean Average Precision (mAP) scores (0.98 and 0.987) and high processing speeds.

\section{Privacy in IoT and Face recognition}

The explosive growth of the Internet of Things, particularly within the intimate setting of the smart home, has introduced a new and complex set of privacy and security challenges. Unlike traditional computing devices, IoT devices are often embedded into everyday objects, collecting vast amounts of granular, and often highly sensitive, personal data without the user's continuous, conscious interaction. This data can range from health metrics and daily routines to audio and video recordings captured by devices like smart speakers and cameras. The collection, transmission, and storage of this sensitive information create a vast surface area for potential security vulnerabilities and privacy breaches.

A central issue is the lack of privacy-by-design principles in many commercially available IoT devices and their corresponding development frameworks. This can lead to a host of security weaknesses, including weak authentication mechanisms, the transmission of unencrypted data, and an absence of user controls for managing personal information. The decentralized and heterogeneous nature of IoT ecosystems further complicates matters. A smart home can consist of devices from multiple manufacturers, each with its own security standards and data handling policies, making it difficult for a user to have a complete understanding and control over their data.

The use of biometric data, such as facial recognition in the context of the proposed Proof-of-Concept (PoC) smart scale, introduces a particularly acute privacy risk. If a biometric database is compromised, the user's identity is permanently at risk. This is a critical area that requires advanced security solutions. The work of Elordi \textit{et al}. \cite{elordi2021optimal} offers a compelling example of how to address this challenge. They propose a system that uses homomorphic encryption to protect this sort of data securely for elderly care applications. Homomorphic encryption allows computations to be performed on encrypted data without the need to decrypt it first. In the context of facial recognition, this means that the face matching process can occur on a server without the server ever having access to the unencrypted biometric template. This approach provides a powerful layer of privacy protection, as even if a database were to be breached, the data would remain encrypted. This PoC should build upon this by exploring secure data handling for facial recognition within a cost-conscious, smart home-oriented architecture, aiming to demonstrate how such advanced privacy measures can be integrated into a practical PoC.

\chapter{The Proof of Concept (PoC)}

This PoC consists of an embedded system with integrated sensors capable of weighing and identifying a subject alongside complementary services for face recognition and data storage. It also offers a simple dashboard interface for managing subject registration (referred as profiles) and visualizing available weight measurements of them realized with the sensor mentioned. This section unfolds the details of designing and implementing the whole system and presents the decision process for every step and piece of it.

\section{Project specification}
\textbf{Functional Requirements}

The functional requirements (FRs) for the system define what it does from certain actor perspectices. The following functional requirements were identified:

\begin{enumerate}
  \item The user shall be able to create profiles through a frontend client
  \begin{enumerate}
    \item When creating a profile the user shall be able to name the profile
    \item When creating a profile the user shall be able to send a picture to be used for face recognition of the subject related to that profile
  \end{enumerate}
  \item The user shall be able to access the available profiles and their available measurements
  \item The user shall be able to measure their weight by stepping up on the scale when stepping up on the scale the system should then use its camera to identify the subject.
\end{enumerate}

\textbf{Nonfunctional Requirements}

Nonfunctional Requirements (NFRs) layout the qualities of a system, or \textit{how} it should perform its functionalities. For this PoC, the following NFR were set:

\begin{enumerate}
  \item The weight measurement must be accurate within an 100 grams margin of error;
  \item The system shall account for measurement or face matching errors and support retry policies;
  \item The system must be easily extensible to consider the possible adition of extra sensors and connection to outside systems;
  \item Privacy is paramount and sensitive data such as biometric data shall never be saved in its raw format.
\end{enumerate}

\section{PoC Overview}

With the functional and nonfunctional requirements established as design constraints, this section presents the architectural approach developed to satisfy them. 

The system consists of three layers: the edge, the fog, and the cloud layer. This layered architecture directly addresses the project's core requirements: the edge layer ensures privacy through local biometric processing (NFR 4), the fog layer enables extensibility through event-driven messaging (NFR 3), and the cloud layer provides data management and visualization capabilities (FR 2). The edge layer consists of a scale, an HX711 signal amplifier and an ESP32. The scale itself consists of a Wheatstone bridge built with straing gauge load cells, connected using standard copper wires. The load cells are then connected to an HX711 signal amplifier that is then connected to the ESP32.

The ESP32 is callibrated using known weights and programmed to poll variations in voltage caused by deformation of the strain gauges when a weight is placed on top of them. The ESP32 module comes with a camera that captures image once a given weight threshold is beated. The microcontroller calibration was done through the polynomial regression of the acquired ADC (voltage) value and respective known weight values, resulting in a curve that is used to map ADC values to weight measurements.

Both image feature vector and weight value are sent to an MQTT broker, which serves as a queue service. For the purpose of this PoC, the broker was set up in a personal computer and executed under a \textbf{docker container} for abstraction \cite{docker}, but it could be deployed on a RaspberryPi or even another ESP32 for its lightweight nature. 

The fog layer consists of the MQTT broker which acts as the gateway between the embedded system and its gathered data users (cloud layer services). Nevertheless, the cloud layer includes both a Hub Service for managing measurements in the database and a dashboard for visualizing available measurements by profile. Still, the broker could arguibly be moved to either the edge or the cloud layers, however, it was kept in the fog layer since it represents a hub for any other smart things in the household, meaning that before sharing their data to the cloud, they would pass through the broker, which then acts as a Gateway.

In order to accomodate the FRs and NFRs, many engineering decisions were made based on literature review and good practices in software engineering and architecture. The embedded system is an ESPCAM (an ESP32 with built-in camera and SD card support) and its software was written in C, using Espressif libraries for MQTT and TensorFlow Lite pre-trained models for extracting  face feature vectors from camera imaging \cite{tflite}. The MQTT broker is the Mosquitto by Eclipse implementation \cite{mosquitto}. Within the cloud layer, the data storage is implemented using PostgreSQL \cite{postgresql} running pgvector \cite{pgvector} plug-in for ease querying and storage of feature vectors. Still within the cloud layer, the Hub Service is implemented following the hexagonal architectural pattern and uses Kotlin \cite{kotlin} with the Spring Boot framework \cite{springboot} for providing a web API and an MQTT client. Finally, we implemented a dashboard in React for easier visualization of the measurements \cite{react}. Figure \ref{fig:overview}\index{overview} shows an overview of the whole solution. Notice in the figure \textbf{MobileApp} is not part of this PoC, but it exemplifies how the system could be easily extended.

\begin{figure}[H]
  \caption{System overview and communication routes}
  \centering
  \includegraphics[width=0.90\textwidth]{overview}\\
  \textbf{Source: Author}
  \label{fig:overview}
\end{figure}

\section{PoC edge layer}

The \textbf{edge layer} contains the embedded solution with a weight sensor and a camera attatched to it. The solution was developed using an ESP32 microcontroller embedded with a 2 megapixel camera (ESPCAM), alongisde an HX711 signal amplifier chip. Figure \ref{fig:physical}\index{physical} shows the actual load cell layout in the PoC, which contains 4 resistors wired together to measure up to 200Kg.

\begin{figure}[H]
  \caption{Physical layout of the scale}
  \centering
  \includegraphics[width=0.90\textwidth]{physical}\\
  \textbf{Source: Author}
  \label{fig:physical}
\end{figure}

The ESP32 is aware of voltage variation to infer weight values based on callibrated reference values. Once a threshold is perceived, the camera is activated and an image is taken of the subject being weighed. Both weight and image information are sent to the MQTT broker.

The callibration of the system was made through the measurement of voltage for known weight values by gradatively adding water to a bottle, measuring its weight with a kitchen scale and then measuring the difference in voltage perceived by the microcontroller. Those values are then fit to a curve through polynomial regression. The resulting sum of powers defines the function that maps Analog to Digital Converter (ADC) voltage read values to weight values. Table \ref{table:calibration_data}\index{table:calibration_data} list 9 samples of ADC readings and their respective already known weights.

\begin{table}[H]
    \centering
    \caption{Raw ADC Readings vs. Known Weights}
    \label{table:calibration_data}
    \begin{tabular}{cc}
        \toprule
        \textbf{ADC Read Voltage} & \textbf{Known Weight (in grams)} \\
        \midrule
        \num{46623} & \num{0} \\
        \num{46680} & \num{34} \\
        \num{47220} & \num{310} \\
        \num{47175} & \num{427} \\
        \num{48030} & \num{630} \\
        \num{47300} & \num{763} \\
        \num{48500} & \num{973} \\
        \num{48790} & \num{1284} \\
        \num{48860} & \num{1579} \\
        \bottomrule
    \end{tabular}
\end{table}

Furthermore, a polynomial regression script reduced the sample data into a curve function that could adjust the voltage values to weight measurements. See listing \ref{lst:script}. Figure \ref{fig:polynomial_fit}\index{polynomial_fit} shows the resulting curve.

\begin{lrbox}{\lstbox}\begin{minipage}{\textwidth}

\begin{lstlisting}[caption=Python Script for data calibration, language=Python, label={lst:script}]
# Polynomial regression
coefficients = np.polyfit(raw_values, weights, 2)
print("Coefficients (highest degree first):", coefficients)

# This gives you: weight = c[0]*x² + c[1]*x + c[2]
# For degree 2: [a2, a1, a0]
\end{lstlisting}

\end{minipage}\end{lrbox}  

\colorbox{lightgray}{\usebox\lstbox}

\begin{figure}[H]
  \caption{Polynomial Regression resulting curve}
  \centering
  \includegraphics[width=0.90\textwidth]{polynomial_fit}\\
  \textbf{Source: Author}
  \label{fig:polynomial_fit}
\end{figure}

Once the weight beats a given threshold of 5 grams the scale is set to retire from its idle state and take a picture of the subject on it. The microcontroller makes use of the pre-trained MobileFaceNet model from TensorFlow Lite library to extract the feature vector from the image \cite{mobilefacenets}. By doing so, the subject image never leaves the \textbf(edge layer) and thus their privacy is protected by avoiding the transmission of possible sensitive biometric data to the \textbf{cloud layer}. Still, this feature vector is enough to query registered profiles in the database and follows the homomorphic encryption approach \cite{jin_providing_2020}. Figure \ref{fig:stateesp}\index{stateesp} shows the state machine representation of the ESP32 microcontroller workflow. 

\begin{figure}[H]
  \caption{State Machine Diagram of the ESP32 workflow}
  \centering
  \includegraphics[width=0.90\textwidth]{stateesp}\\
  \textbf{Source: Author}
  \label{fig:stateesp}
\end{figure}

At IdleState The system is in standby mode, waiting for the weight threshold crossing trigger. At WeightMeasuringState, the system actively reads data from the scale until the value becomes stable when sampling and the system reaches the WeightStabilizedState. Once weight is stable, the microcontroller achieves the FaceDetectionState in which the camera is activated to detect and capture a humance face. With the image captured, its feature vector is built during FaceFeatureExtractionState and then the system enters into the MeasurementCastState, when all data is packaged and sent to the MQTT broker. The system goes back to IdleState once no weight is measured and/or it is notified of success or failure in face matching.

\section{PoC fog layer}

The \textbf{fog layer} consists of the intermediate services and tools for the system to work, however it still remains within the household domain. This means information here is still private to the local network (LAN). This layer can be deployed to serve as an IoT Hub for smart things in the house to communicate between themselves.

Within this project, this layer contains the \textbf{MQTT Broker}, which acts as a queue service bridging the edge and cloud layers. This is done by representing tasks as events to be parsed and reacted upon by the other layers. Therefore, the MQTT Broker serves as a queue service for bridging the edge layer to the services that depend on its output. Furthermore, the MQTT Broker and the fog layer as a whole (which could contain auxiliary services, for example), act as a hub for any other embedded devices in the environment.

In this schema, the ESP32 \textit{publishes} a message to the broker as a \textbf{MeasurementTakenUnprofiled} event, which contains a \textbf{topic} name, a weight value and a vector of embeddings. The topic represents something similar to a table in a Database Management System (DBMS) and is used to separate event contexts. Consequently, the HubService \textit{consumes} the message and attempts to find the closer vector in the database and sends back a \textbf{MeasurementRegisteredProfiled} event so that the EPS32 is made aware everything went as expected (see Figure \ref{fig:eventflowok}\index{eventflowok}). If the image does not match any registed profile, then the ESP32 is notified through the publishing of an \textbf{MeasurementFailedUnprofiled} event in the MQTT broker (see Figure \ref{fig:eventflownotok}\index{eventflownotok}).

This workflow follows and Event-Driven Architecture (EDA) and is made possible through the definition of topics within the MQTT broker. Topics are similar to tables in which they represent a specific concept or event, however in practice topics represent a queue or a stream within a broker that handles many topics. User services publish or consume from specific topics within the broker. Each event is always sent to its own topic, and services subscribe and publish to their topics of concern. Figure \ref{fig:mqttbroker}\index{mqttbroker} illustrates the MQTT broker topics and related publishers and subscribers. 

\begin{figure}[H]
  \centering
  \caption{Event flows}
  \begin{subfigure}{0.70\textwidth} % Adjust width as needed
    \includegraphics[width=\linewidth]{eventflowok.png}
    \caption{Event Flow when face is recognized}
    \label{fig:eventflowok}
  \end{subfigure}
  \hfill % Adds horizontal space between subfigures
  \begin{subfigure}{0.70\textwidth} % Adjust width as needed
    \includegraphics[width=\linewidth]{eventflownotok.png}
    \caption{Event Flow when face is not recognized}
    \label{fig:eventflownotok}
  \end{subfigure}\\
  \textbf{Source: Author}
  \label{fig:eventflows}
\end{figure}

\begin{figure}[H]
  \caption{MQTT Broker Topics and workflow}
  \centering
  \includegraphics[width=0.90\textwidth]{mqttbroker}\\
  \textbf{Source: Author}
  \label{fig:mqttbroker}
\end{figure}

\section{PoC cloud layer}

The \textbf{cloud layer} is comprised of the HubService and a PostgreSQL database for storing profiles, their face embeddings and their measurements. The HubService is implemented following the Hexagonal Architectural Pattern and consists of an API for managing accessing database records and an MQTT client to consume and publish events to the MQTT broker in the \textbf{fog layer}. For this PoC, a dashboard serves as an example application of how the system could be used. The dashboard serves for managing profiles and visualizing the measured weights for them.

The database is designed to be simple and yet efficient, storing data in three tables: \textbf{profile}, \textbf{profile measurement}, and \textbf{profile embedding}. The \textbf{profile} table stores scale users information and identifies them with an Universally Unique Identifier (UUID). The \textbf{profile measurement} records holds a reference identifier to the profile they belong to and the weight measurement value. Finally, the \textbf{profile embedding} table stores available feature vectors for a profile to be used by face matching algorithms. PostgreSQL is set up with the \textbf{pgvector} plug-in that allows for the storage and retrieval of vector types in an efficient manner. Figure \ref{fig:der}\index{der} shows the Entity-relationship Diagram of the database. This schema places profiles as owners of measurements and embeddings. From this perspective, queries remain simple and dedicated API endpoints make it easy to manipulate each entity separately or as collections. For example, given a profile identifier, it is possible to query its related embeddings and measurements directly. This is very convenient for the construction of data visualization tools, such as the dashboard.

\begin{figure}[H]
  \caption{Entity-Relationship Diagram of the Database}
  \centering
  \includegraphics[width=0.90\textwidth]{der}\\
  \textbf{Source: Author}
  \label{fig:der}
\end{figure}

The HubService was developed in the Kotlin programming language and used the Spring Boot framework. It contains a REST controller for receiving HTTP requests from web clients and an MQTT adapter for publishing and subscribing to a broker.

The REST API serves endpoints for managing profiles, which includes creating, updating, and deleting profiles, as well as reading the available ones in the database. The API also contains two extra endpoints for adding embeddings to a profile and for retrieving the measurements of a profile. Table \ref{table:api_endpoints}\index{api_endpoints} the available endpoints.

\begin{table}[H]
    \centering
    \caption{HubService API Endpoints}
    \label{table:api_endpoints}
    \resizebox{\textwidth}{!}{\begin{tabular}{|l|l|l|}
        \hline
        \textbf{Method} & \textbf{Endpoint} & \textbf{Description} \\
        \hline
        GET & /api/profiles & Retrieve all available profiles. \\
        \hline
        POST & /api/profiles & Create an instance of profiles. \\
        \hline
        GET & /api/profiles/\{\{id\}\} & Retrieve an instance of profiles. \\
        \hline
        PUT & /api/profiles/\{\{id\}\} & Update the information of a profile. \\
        \hline
        DELETE & /api/profiles/\{\{id\}\} & Destroy an instance of profiles given its UUID. \\
        \hline
        \multicolumn{3}{|c|}{} \\ % Separator row
        \hline
        GET & /api/measurements & Retrieve all available measurements. \\
        \hline
        POST & /api/measurements & Create an instance of measurements. \\
        \hline
        GET & /api/measurements/by-profile/\{\{profileId\}\} & Retrieve all measurements that belong to the same profile, given the profile UUID. \\
        \hline
        GET & /api/measurements/\{\{id\}\} & Retrieve a measurement given its UUID. \\
        \hline
        DELETE & /api/measurements/\{\{id\}\} & Destroy an instance of measurements given its UUID. \\
        \hline
        \multicolumn{3}{|c|}{} \\ % Separator row
        \hline
        GET & /api/embeddings & Retrieve all available embeddings. \\
        \hline
        POST & /api/embeddings & Create an instance of embeddings. \\
        \hline
        GET & /api/embeddings/by-profile/\{\{profileId\}\} & Retrieve all embeddings that belong to the same profile, given the profile UUID. \\
        \hline
        GET & /api/embeddings/\{\{id\}\} & Retrieve an embedding given its UUID. \\
        \hline
        DELETE & /api/embeddings/\{\{id\}\} & Destroy an instance of embeddings given its UUID. \\
        \hline
    \end{tabular}}
\end{table}

Notice that even though the endpoint \textbf{POST /api/measurements} is available in the API, it was used solely for testing. Real measurements should come from the smart scale only. This is done through the implementation of an MQTT client placed as an incoming adapter within the Hexagonal Architecture of the HubService. Figure \ref{fig:hexagonal}\index{hexagonal} showcases why this architecture is so versatile. Many different types of service can be moderately easily coupled into the architecture without disrupting what already exists \cite{seo_hepa_2015} and keeping decoupling between classes high. The domain model holds not only the data structure of the base entities, but also the business model of the system. The domain however is not concerned with is use cases, therefore its code remain clean and agnostic. The upper layers in the architecture give context and purpose to these definitions, in such a way that dependencies never goes inwards \cite{vernon_implementing_2013}.

\begin{figure}[H]
  \caption{Hexagonal Architecture of the HubService}
  \centering
  \includegraphics[width=0.90\textwidth]{hexagonal}\\
  \textbf{Source: Author}
  \label{fig:hexagonal}
\end{figure}

Alongside the REST API, the Dashboard allows for using the API through a graphical user interface (GUI). Even though it is simple, it lets the smart scale users follow up all measurements available per profile. Figure \ref{fig:dss_dashboard}\index{dss_dashboard} shows a sequence diagram for this feature. The user of the dashboard selects a profile and then the client logic fetches measurements for that profile by reaching to the responsible API endpoint in the HubService, which connects to the database and finally produces the response to the dashboard.

\begin{figure}[H]
  \caption{Dashboard Sequence Diagram for Retrieving Measurements of a given Profile}
  \centering
  \includegraphics[width=0.90\textwidth]{dss_dashboard}\\
  \textbf{Source: Author}
  \label{fig:dss_dashboard}
\end{figure}

\section{Smart Scale Face Recognition}

The face recognition implementation represents the convergence of multiple architectural decisions described in previous sections, particularly the privacy-by-design approach (NFR 4) and the event-driven architecture that supports retry mechanisms (NFR 2). Specially, the set privacy concerns required novel solutions. The images used for profile matching are never stored in order to keep privacy untouched. The project uses an homomorphic encryption approach in which the feature vector of the system is used to represent it. This method allows for searching and comparing images without the raw data.

This is made possible through the usage of the pgvector plugin within the PostgreSQL database used. It allows for storage and query of vector, which eases the process of matching profiles to weighing subjects. The one-to-many relationship between profile and profile embedding database entities allow for more chances of matching a scenario in which the machine learning models deployed do not take advantage of top-notch hardware, and are in the contrary very limited in resources.

Therefore, both during the registration of a profile and the taking of an image by the ESP32, the image embeddings are taken and used in place of the raw image data. This way biometric information never reaches the \textbf{cloud layer}.

\section{Project Evaluation}

The PoC was evaluated in terms of how well the novel approaches proposed in literature could actually be implemented. More than that, we evaluate the face matching performance when using pre-trained models that can run on an ESP32 and the overrall performance of the system by measuring latency of data flow across the whole solution.

In order to measure face matching performance we compare different lighting conditions and percentage of retry request events in the communication between edge layer and cloud layer through the MQTT broker. Besides that, for performance we consider the different time values that are created for measurements, being those: measurement time (the moment the ESP32 sends the event with the measured value); and record time (the moment the measurement is recorded in the database). Nevertheless, those  Key Performance Indicators (KPIs) combined serve the purpose of evaluating the feasability and aplicability of the novel approaches gathered in the theorical foundation.

A subject profile is created through the Dashboard. Figure \ref{fig:dashboard_empty}\index{dashboard_empty} shows the interface in which you click the button to create a new profile, set a name and send a picture for face recognition reference, such as Figure \ref{fig:dashboard_profile}\index{dashboard_profile} shows. No entries will show up for the profile until measurements are taken (see Figure \ref{fig:dashboard_created}\index{dashboard_created}). Then, to measure their weight the person stands on the scale and holds the ESPCAM to their face as shown in Figure \ref{fig:scale_standing}\index{scale_standing}. Once face recognition is done successfully, the Dashboard will show a new entry (see Figures \ref{fig:dashboard_measurement}\index{dashboard_measurement} and \ref{fig:dashboard_measurement_kilos}\index{dashboard_measurement_kilos}).

\begin{figure}[H]
  \centering
  \caption{Dashboard Profile creation}
  \label{fig:eventflows}
  \begin{subfigure}{0.70\textwidth} % Adjust width as needed
    \includegraphics[width=\linewidth]{dashboard_empty.png}
    \caption{Empty Dashboard}
    \label{fig:dashboard_empty}
  \end{subfigure}
  \hfill % Adds horizontal space between subfigures
  \begin{subfigure}{0.70\textwidth} % Adjust width as needed
    \includegraphics[width=\linewidth]{dashboard_profile.png}
    \caption{Profile creation}
    \label{fig:dashboard_profile}
  \end{subfigure}
    \hfill % Adds horizontal space between subfigures
  \begin{subfigure}{0.70\textwidth} % Adjust width as needed
    \includegraphics[width=\linewidth]{dashboard_created.png}
    \caption{Empty Profile}
    \label{fig:dashboard_created}
  \end{subfigure} \\
  \textbf{Source: Author}
\end{figure}

\begin{figure}[H]
  \caption{Subject weighin themselves on scale}
  \centering
  \includegraphics[width=0.90\textwidth]{scale_standing}\\
  \textbf{Source: Author}
  \label{fig:scale_standing}
\end{figure}


\begin{figure}[H]
  \centering
  \caption{Dashboard Profile measurement}
  \begin{subfigure}{0.70\textwidth} % Adjust width as needed
    \includegraphics[width=\linewidth]{dashboard_measurement.png}
    \caption{Measurement in grams}
    \label{fig:dashboard_measurement}
  \end{subfigure}
  \hfill % Adds horizontal space between subfigures
  \begin{subfigure}{0.70\textwidth} % Adjust width as needed
    \includegraphics[width=\linewidth]{dashboard_measurement_kilos.png}
    \caption{Measurement in Kilograms}
    \label{fig:dashboard_measurement_kilos}
  \end{subfigure}\\
  \textbf{Source: Author}
  \label{fig:eventflows}
\end{figure}

From repetitive testing and measurement of weights, the gathered information shows that face recognition on the edge layer takes some considerable time, leading to 1 to 2 seconds of delay when compared with the sending of the weight value only, which happens almost instantly. Overrall, the system is fast, but every component is running in the same network. In the ocasion of communicating with a real cloud service, performance could differ depending on internet connection quality.

\phantompart

% ---
% Conclusão
% ---
\chapter{Conclusion}
\section{Contributions}

This work presents a comprehensive proof-of-concept (PoC) implementation of an IoT smart scale with facial recognition capabilities designed specifically for smart home integration. The project makes several significant contributions to the field of IoT systems and smart home technology starting by its Privacy-by-Design approach. The PoC demonstrates a practical implementation of homomorphic encryption principles in a resource-constrained embedded environment. By extracting facial feature vectors at the edge layer using the MobileFaceNet model from TensorFlow Lite, the system ensures that raw biometric data never leaves the user's control. This approach addresses one of the most critical concerns in IoT adoption—privacy and security of sensitive personal information.

The project achieves its goal within an affordable budget and accessible hardware components. The use of an ESP32 microcontroller (ESPCAM), HX711 signal amplifier, and standard strain gauge load cells provides a compelling alternative to expensive commercial solutions, addressing the affordability barrier identified by Mafong et al. (2020) as a significant obstacle to smart scale adoption.

The implementation also validates the effectiveness of an event-driven architecture (EDA) using MQTT as a lightweight messaging protocol for IoT systems. This architectural choice enables loose coupling between system components, facilitating easy extensibility and scalability. The three-layer architecture (edge, fog, and cloud) with clear separation of concerns provides a reference model for future IoT smart home applications. Aligned with that, the HubService implementation following the hexagonal architectural pattern demonstrates how domain-driven design principles can be effectively applied to IoT backend services. This approach ensures that the business logic remains agnostic to infrastructure concerns, allowing for multiple adapters (REST API, MQTT client) to coexist without compromising the core domain model. Still, the fog layer implementation, centered around the MQTT broker, creates a foundation for a comprehensive smart home ecosystem. The architecture naturally accommodates the addition of new sensors and devices without requiring modifications to existing components, supporting the scalability requirements identified in the literature.

\section{Discussion}

The development and implementation of this PoC revealed several important insights regarding the practical challenges and trade-offs inherent in building privacy-conscious IoT systems for smart homes.

One of the primary technical challenges encountered during implementation was achieving stable weight readings from the strain gauge sensors. The analog nature of load cell measurements introduces noise and variability, particularly when subjects first step onto the scale. The system requires a brief stabilization period before capturing an accurate measurement, which impacts the user experience. Future iterations should implement more sophisticated digital filtering techniques, such as signal filters, to reduce measurement latency while maintaining accuracy.

% Facial Recognition Performance Under Variable Conditions: The lightweight MobileFaceNet model, while resource-efficient enough to run on the ESP32, exhibits sensitivity to environmental factors, particularly lighting conditions. During testing, recognition accuracy varied significantly between well-lit environments and low-light conditions. The retry policy implemented through the event-driven architecture helps mitigate failed recognition attempts, but it adds latency to the overall system response time. This trade-off between privacy (processing at the edge), cost (limited hardware capabilities), and performance (recognition accuracy) represents a fundamental challenge in edge computing applications.

% System Latency and Real-Time Performance: The evaluation framework defined in Section 3.7 identifies three key performance indicators: measurement time (when the ESP32 captures and sends the weight), record time (when the database persists the measurement), and creation time (when the HubService processes the event). The asynchronous nature of the event-driven architecture introduces inherent latency between these stages. While this design choice enhances system resilience and extensibility, it means that users do not receive immediate feedback on their measurements. For a health monitoring application where real-time feedback may be desirable, this represents a meaningful design trade-off.

The decision to perform facial feature extraction at the edge layer rather than in the cloud exemplifies the fundamental tension between privacy and processing power in IoT systems. While this approach successfully protects user privacy by never transmitting raw images, it constrains the system to using lightweight models that can run on resource-limited hardware. More sophisticated facial recognition models that might offer better accuracy under challenging conditions require computational resources beyond what the ESP32 can provide. This limitation underscores the need for continued research into efficient edge computing algorithms specifically designed for privacy-sensitive applications. Nevertheless, other mixed architectures that place face recognition on the fog layer take privacy risks but might provide better user experience.

Regarding the cloud layer, the hexagonal architecture employed in the HubService proved highly effective in accommodating multiple interfaces (REST API, MQTT client) without compromising the core business logic. The use of ports and adapters facilitated the integration of the dashboard as a client application and could easily support additional clients, such as mobile applications or integration with other smart home platforms. This architectural pattern aligns well with the recommendations of Seo et al. (2015) for IoT platform architectures and validates their applicability to smart home contexts.

The integration of PostgreSQL with the pgvector plugin for storing and querying facial embeddings represents an elegant solution to the challenge of matching subjects to profiles without storing raw biometric data. The vector similarity search capabilities enable efficient matching even with multiple embeddings per profile, which helps compensate for the lower accuracy of lightweight recognition models by allowing users to register multiple reference images under different conditions.

Finally, several limitations of the current PoC should be acknowledged. First, the system has been tested primarily in controlled conditions with a very limited number of users. Also, the facial recognition system does not currently implement measures to prevent spoofing attacks (e.g., using photographs), which would be essential for security-critical applications. Still, considering the scope of the work and the context of this application, those limitations do not affect the overall contribution of this work. Within a domestic use case, connection issues are not likely to happen in the Local Area Network (LAN) and for privacy, the homomorphic encryption keeps user identity anonymous as well as sensitive data away from the network as a whole. Not only that, the MQTT broker working as bridge also limits the direct connection to the camera in the ESP32.

\section{Future work}

This proof-of-concept demonstrates that it is possible to build sophisticated, privacy-conscious IoT systems for smart homes using affordable hardware and well-architected software. While challenges remain in optimizing performance and addressing real-world deployment complexities, the project validates key architectural principles and provides a foundation for future research and development in this rapidly evolving field. The insights gained from this work contribute to the broader understanding of the trade-offs between cost, privacy, and performance in IoT systems and demonstrate practical approaches to addressing the barriers to IoT adoption in smart home contexts. Nevertheless, large-scale testing with diverse user populations, varying environmental conditions, and extended time periods would be necessary to fully validate the system's robustness.

The PoC developed in this project establishes a foundation for numerous research directions and practical applications in the IoT and smart home domains. The architecture and privacy-preserving approaches demonstrated in this PoC can be extended to create comprehensive health monitoring systems within the Internet of Medical Things paradigm. Integration with additional biometric sensors (blood pressure monitors, glucose meters, BMI) following the same event-driven architecture would enable holistic health tracking while maintaining the privacy-by-design principles. Such systems could facilitate remote patient monitoring, enabling healthcare providers to track vital signs and intervene proactively when anomalies are detected. The MQTT-based messaging infrastructure is well-suited for aggregating data from multiple health monitoring devices, and the hexagonal architecture of the HubService could easily accommodate adapters for medical data standards.

% ---
% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
% Retire o comentário somente se o padrão exigir que daqui para a
% frente não haja número de páginas.
%\postextual
% ----------------------------------------------------------

% ------
\bibliography{refs.bib}
% ------

%---------------------------------------------------------------------
% INDICE REMISSIVO
%---------------------------------------------------------------------
\phantompart
\printindex
%---------------------------------------------------------------------
\end{document}
